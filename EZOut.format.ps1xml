<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 1.9: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Configuration>
  <SelectionSets>
    <SelectionSet>
      <Name>FileSystemTypes</Name>
      <Types>
        <TypeName>System.IO.DirectoryInfo</TypeName>
        <TypeName>System.IO.FileInfo</TypeName>
      </Types>
    </SelectionSet>
  </SelectionSets>
  <Controls>
    <Control>
      <Name>FileSystemTypes.TreeNode</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$Branch,$trunk = '├──', '    '
if ($script:treeDepth) {
    [Environment]::Newline + ($trunk * $script:TreeDepth)+ $Branch
} else {
    $Branch
}
$script:TreeDepth++;</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        if (-not $_.EnumerateFiles) { return $false }
        foreach ($f in $_.EnumerateFiles()) {$f;break}
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.EnumerateFiles()
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>FileSystemTypes.TreeNode</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        if (-not $_.EnumerateDirectories) { return $false }
        foreach ($f in $_.EnumerateDirectories()) {$f;break}
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        foreach ($d in $_.EnumerateDirectories()) {
            if ($d.Attributes -band 'Hidden') { continue }
            $d
        }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>FileSystemTypes.TreeNode</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth--;</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>ProcessGroupControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)


        . $EZOut_Indent $_.ProcessName
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>
        . $EZOut_Indent $_.Path
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>XmlNodeControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$Branch,$trunk = '', '    '
if ($script:treeDepth) {
    [Environment]::Newline + ($trunk * $script:TreeDepth)+ $Branch
} else {
    $Branch
}
$script:TreeDepth++;</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Tag'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> '&lt;'.Trim() </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Element'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.LocalName
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.HasAttributes -and '#text', '#whitespace' -notcontains $_.LocalName
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_.Attributes</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlAttributeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Tag'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        if ($_.HasChildren -or $_.HasChildNodes) {
            '&gt;'
        } else {
            '/&gt;'
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.InnerText'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -eq '#text' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_.InnerText </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.HasChildren -or $_.HasChildNodes -and $_.LocalName -ne '#whitespace'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    @(foreach ($cn in $_.ChildNodes) {
        if ($cn.LocalName -eq '#whitespace') { continue }
        $cn
    })
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlNodeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Tag'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        if (-not ($_.HasChildren -or $_.HasChildNodes)) {
            ''
        } else {
            [Environment]::NewLine + (' ' * ($script:TreeDepth - 1)* 4) + '&lt;/'
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Element'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
         if ($_.HasChildren -or $_.HasChildNodes) { $_.LocalName}
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Tag'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
         if ($_.HasChildren -or $_.HasChildNodes) {'&gt;'}
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth--;</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeBase</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> '  *' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeEventControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  * ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Warning'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <Text>(</Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.EventHandlerType.GetMethod('Invoke') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $MethodParameters = @($_.EventHandlerType.GetMethod('Invoke').GetParameters())
        foreach ($n in 0..($MethodParameters.Count - 1)) {
            $o =[PSObject]::new($MethodParameters[$n])
            $o.psobject.properties.add([PSNoteProperty]::new('N', $N))
            $o
        }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodParameterControl</CustomControlName>
              </ExpressionBinding>
              <Text>)</Text>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeFieldControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  * '</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>FieldType</PropertyName>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'Warning'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMemberControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        'RuntimeMethodInfo', 'RuntimeConstructorInfo' -contains $_.GetType().Name
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetType().Name -eq 'RuntimePropertyInfo' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypePropertyControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        
        'MdFieldInfo', 'RtFieldInfo' -contains $_.GetType().Name 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeFieldControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetType().Name -eq 'RuntimeEventInfo' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeEventControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMethodControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  *' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.IsStatic </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> ' static ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.IsConstructor </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.DeclaringType </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $_.IsConstructor -and $_.ReturnType </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.ReturnType </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'Warning'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $_.IsConstructor </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> ' ' +  $_.Name </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' (' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $MethodParameters = @($_.GetParameters())
        foreach ($n in 0..($MethodParameters.Count - 1)) {
            $o =[PSObject]::new($MethodParameters[$n])
            $o.psobject.properties.add([PSNoteProperty]::new('N', $N))
            $o
        }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodParameterControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ')' </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMethodParameterControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.N -gt 0</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> ', ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>ParameterType</PropertyName>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'Warning'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '$' + $_.Name </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' ' </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeNameControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text> [</Text>
              <ExpressionBinding>
                <ScriptBlock>
        if ($_.FullName) {
            $_.Fullname -replace '`.+', '' -replace '^System\.', ''
        } else {
            $_.Name -replace '`.+', '' -replace '^System\.', ''
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.IsGenericType
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GenericTypeArguments
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <Text>]</Text>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypePropertyControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  * '</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>PropertyType</PropertyName>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'Warning'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        ' {' +
        $(if ($_.CanRead) {'get;'}) +
        $(if ($_.CanWrite) {'set;'})+
        '}'
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>XmlAttributeControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.AttributeName'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        ' ' + $_.Name
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Punctuation'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $null = $_.OuterXml -match '=\s{0,}(?&lt;q&gt;["''])'
        if ($matches.Q) {
            '=' + $matches.Q
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.AttributeValue'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        [security.SecurityElement]::Escape($_.Value)
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_SetOutputStyle -ForegroundColor 'EZOut.Xml.Punctuation'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $null = $_.OuterXml -match '=\s{0,}(?&lt;q&gt;["''])'
        $matches.Q
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>$EZOut_Indent</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Indents content
.Description
    Indents content.

    In most scenarios, content is indented by a number of spaces

    If $request or $host.UI.SupportsHTML, this will render a div tag with margin-left set to $Length ex 
    (this is the equivilent of N characters of indentation in HTML)
.Notes
    IsFormatPart: true
#&gt;
param(
$Content,

[ValidateRange(0,100)]
[Alias('Spaces')]
[uint32]
$Length = 4
)

if ($Request -or $Host.UI.SupportsHTML) {
    return "&lt;div style='margin-left:${Length}ex'&gt;$content&lt;/div&gt;"
}

(' ' * $Length) + "$content"</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>$EZOut_SetOutputStyle</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Adds style to a format output
.Description
    Adds style information to a format output, including:

    * ForegroundColor
    * BackgroundColor
    * Bold
    * Underline
.Notes
    Stylized Output works in two contexts at present:
    * Rich consoles (Windows Terminal, PowerShell.exe, Pwsh.exe) (when $host.UI.SupportsVirtualTerminal)
    * Web pages (Based off the presence of a $Request variable, or when $host.UI.SupportsHTML (you must add this property to $host.UI))

    IsFormatPart: true
#&gt;
param(
[string]$ForegroundColor,
[string]$BackgroundColor,
[switch]$Bold,
[switch]$Underline,
[switch]$Invert
)

$canUseANSI = $host.UI.SupportsVirtualTerminal
$canUseHTML = $Request -or $host.UI.SupportsHTML
if (-not ($canUseANSI -or $canUseHTML)) { return }

$knownStreams = @{
    Output='';Error='BrightRed';Warning='BrightYellow';
    Verbose='BrightCyan';Debug='Yellow';Progress='Cyan';
    Success='BrightGreen';Failure='Red';}
$standardColors = 'Black', 'Red', 'Green', 'Yellow', 'Blue','Magenta', 'Cyan', 'White'
$brightColors   = 'BrightBlack', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue','BrightMagenta', 'BrightCyan', 'BrightWhite'
$n =0
$cssClasses = @()
$styleAttributes =
    @(:nextColor foreach ($hc in $ForegroundColor,$BackgroundColor) {
        $n++
        if (-not $hc) { continue }
        if ($hc[0] -eq [char]0x1b) {
            if ($canUseANSI) { 
                $hc; continue
            }
        }

        $ansiStartPoint = if ($n -eq 1) { 30 } else { 40 } 
        if ($knownStreams.ContainsKey($hc)) {
            $i = $brightColors.IndexOf($knownStreams[$hc])
            if ($canUseHTML) {
                $cssClasses += $hc
            } else {
                if ($i -ge 0 -and $canUseANSI) {
                    '' + [char]0x1b + "[1;$($ansiStartPoint + $i)m"
                } else {
                    $i = $standardColors.IndexOf($knownStreams[$hc])
                    if ($i -ge 0 -and $canUseANSI) {
                        '' + [char]0x1b + "[1;$($ansiStartPoint + $i)m"
                    } elseif ($i -le 0 -and $canUseANSI) {                        
                        '' + [char]0x1b + "[$($ansistartpoint + 8):5m"
                    }
                }
            }
            continue nextColor
        }
        elseif ($standardColors -contains $hc) {
            for ($i = 0; $i -lt $standardColors.Count;$i++) {
                if ($standardColors[$i] -eq $hc) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        '' + [char]0x1b + "[$($ansiStartPoint + $i)m"
                    } else {
                        $cssClasses += $standardColors[$i]
                    }
                    continue nextColor
                }
            }
        } elseif ($brightColors -contains $hc) {
            for ($i = 0; $i -lt $brightColors.Count;$i++) {
                if ($brightColors[$i] -eq $hc) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        '' + [char]0x1b + "[1;$($ansiStartPoint + $i)m"
                    } else {
                        $cssClasses += $standardColors[$i]
                    }
                    continue nextColor
                }
            }
        }


        if ($hc -and -not $hc.StartsWith('#')) { 
            $placesToLook=
                @(if ($hc.Contains('.')) {
                    $module, $setting = $hc -split '\.', 2
                    $theModule = Get-Module $module
                    $theModule.PrivateData.Color,
                        $theModule.PrivateData.Colors,
                        $theModule.PrivateData.Colour,
                        $theModule.PrivateData.Colours,
                        $theModule.PrivateData.EZOut,
                        $global:PSColors,
                        $global:PSColours
                } else {
                    $setting = $hc
                    $moduleColorSetting = $theModule.PrivateData.PSColors.$setting
                })

            foreach ($place in $placesToLook) {
                if (-not $place) { continue }
                foreach ($propName in $setting -split '\.') {
                    $place = $place.$propName
                    if (-not $place) { break }
                }
                if ($place -and "$place".StartsWith('#') -and 4,7 -contains "$place".Length) {
                    $hc = $place
                    continue
                }
            }
            if (-not $hc.StartsWith -or -not $hc.StartsWith('#')) {
                continue
            }
        }
        $r,$g,$b = if ($hc.Length -eq 7) {
            [int]::Parse($hc[1..2]-join'', 'HexNumber')
            [int]::Parse($hc[3..4]-join '', 'HexNumber')
            [int]::Parse($hc[5..6] -join'', 'HexNumber')
        }elseif ($hc.Length -eq 4) {
            [int]::Parse($hc[1], 'HexNumber') * 16
            [int]::Parse($hc[2], 'HexNumber') * 16
            [int]::Parse($hc[3], 'HexNumber') * 16
        }

        if ($canUseHTML) {
            if ($n -eq 1) { "color:$hc" }
            elseif ($n -eq 2) { "background-color:$hc"} 
        }
        elseif ($canUseANSI) {
            if ($n -eq 1) { [char]0x1b+"[38;2;$r;$g;${b}m" }
            elseif ($n -eq 2) { [char]0x1b+"[48;2;$r;$g;${b}m" }
        }
        
    })


if ($Bold) {
    $styleAttributes += 
        if ($canUseHTML) {
            "font-weight:bold"
        }
        elseif ($canUseANSI) 
        {
            [char]0x1b + "[1m"
        }
}

if ($Underline) {
    $styleAttributes += 
        if ($canUseHTML) {
            "text-decoration:underline"
        } elseif ($canUseANSI) {
            [char]0x1b + "[4m"
        }
}

if ($Invert) {
    $styleAttributes += 
        if ($canUseHTML) {
            "filter:invert(100%)"
        } elseif ($canUseANSI) {
            [char]0x1b + "[7m"            
        }
}

if ($canUseHTML) {
   
    "&lt;span$(
        if ($styleAttributes) { " style='$($styleAttributes -join ';')'"}
    )$(
        if ($cssClasses) { " class='$($cssClasses -join ' ')'"}
    )&gt;"
} elseif ($canUseANSI) {
    $styleAttributes -join ''
}</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>$EZOut_ClearOutputStyle</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Clears the output style
.Description
    Clears ANSI output style or closes the most recent span element.

    ANSI stylization can be toggled off individually (for instance, to stop applying an -Underline but leave the color unchanged)
.Notes
    IsFormatPart: true
#&gt;
param(
# If set, will explicitly clear ANSI Bold
[switch]
$Bold,
# If set, will explicitly clear ANSI Underline
[switch]
$Underline,
# If set, will explicitly clear ANSI Invert
[switch]
$Invert,
# If set, will explicitly clear ANSI Foreground Color
[switch]
$ForegroundColor,
# If set, will explicitly clear ANSI Background Color
[switch]
$BackgroundColor
)
@(if ($request -or $host.UI.SupportsHTML) {
    "&lt;/span&gt;"
} elseif ($Host.UI.SupportsVirtualTerminal) {
    if ($Underline) {
        [char]0x1b + "[24m"
    }
    if ($Bold) {        
        [char]0x1b + "[21m"
    }
    if ($Invert) {
        [char]0x1b + '[27m'
    }
    if ($ForegroundColor) {
        [char]0x1b + '[39m'
    }
    if ($BackgroundColor) {
        [char]0x1b + '[49m'
    }

    if (-not ($Underline -or $Bold -or $Invert -or $ForegroundColor -or $BackgroundColor)) {
        [char]0x1b + '[0m'
    }
    
}) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>$EZOut_Heading</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Renders a heading
.Description
    Renders a heading.

    If $request or $host.UI.SupportsHTML, this will render heading tags.

    Otherwise, this will render Markdown style headings
.Notes
    IsFormatPart: true
#&gt;
param(
# The content inside of the heading
$Content,

# The level of heading
[ValidateRange(1,6)]
[int]
$Level = 2,

# If using SeText style headings (a line followed by a line of equals or a line of dashes)
# -UnderlineLength will adjust the length of the second line.
[int]
$UnderlineLength,

# If set, will render all markdown headings as ATX style, rather than SeText style
# (ATX style always starts with a comment, SeText styles are underlined)
[switch]
$NoSeText
)

if ($Request -or $Host.UI.SupportsHTML) {
    "&lt;h$level&gt;$Content&lt;/h$level&gt;"
} else {
    if ($Level -eq 1 -and -not $NoSeText) {
        '' + $Content + [Environment]::NewLine + ('=' * $(if ($UnderlineLength) { $UnderlineLength } else {$Content.Length})) + [Environment]::NewLine
    } elseif ($Level -eq 2 -and -not $NoSeText) {
        '' + $Content + [Environment]::NewLine + ('-' * $(if ($UnderlineLength) { $UnderlineLength } else {$Content.Length})) + [Environment]::NewLine
    } else {
        [Environment]::NewLine + ('#' * $Level) + ' ' + $Content
    }
}</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>$EZOut_Heatmap</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Heatmaps a value
.Description
    Determines the appropriate temperature color of a value, given a -Cool and -Hot color (passed as ints)
.Notes
    IsFormatPart: true
#&gt;
param(
# The value that will be heatmapped.
$Value,

# The maximum, by default 1gb
[Parameter(Mandatory)]
$Max = 1gb,

# The middle value, by default 512mb
$Middle = 512mb,

# The minimum value, by default 0
$Min = 0,

# The color for cool.
# To pass a Hex color as an int, simply replace # with 0x
# (e.g. 0x00ff00 for green instead of '#00ff00') 
[int]
$Cool =0x05dd00,

# The color for hot.
# To pass a Hex color as an int, simply replace # with 0x
# (e.g. 0xff0000 for red instead of '#ff0000') 
[int]
$Hot = 0xef1100
)

# Separate out the segments of the color,
$coolRedPart = [byte](($Cool -band 0xff0000) -shr 16) # by bitmasking and then shifting right until it's bytes
$coolGreenPart = [byte](($Cool -band 0x00ff00) -shr 8)
$coolBluePart = [byte]($Cool -band 0x0000ff)

$hotRedPart = [byte](($hot -band 0xff0000) -shr 16)
$hotGreenPart = [byte](($hot -band 0x00ff00) -shr 8)
$hotBluePart = [byte]($hot -band 0x0000ff)

"#{0:x2}{1:x2}{2:x2}" -f @(

if ($Value -le $Min) 
{
    $coolRedPart, $coolGreenPart, $coolBluePart
}
elseif ($Value -ge $Max) 
{
    $hotRedPart, $hotGreenPart, $hotBluePart
} else {
    if ($Value -le $Middle) 
    {
        $d = 1 - ([double]$value / ($Middle - $min))
        [Byte][Math]::Min(255, $hotRedPart * $d + $coolRedPart)
        [Byte][Math]::Min(255, $hotGreenPart * $d + $coolGreenPart)            
        [Byte][Math]::Min(255, $hotBluePart * $d + $coolBluePart)
    } else
    {
        $d = 1 - ([double]$value / ($Max - $Middle))
        [Byte][Math]::Min(255, $coolRedPart * $d + $hotRedPart)
        [Byte][Math]::Min(255, $coolGreenPart * $d + $hotGreenPart)            
        [Byte][Math]::Min(255, $coolBluePart * $d + $hotBluePart)
    }
}
)</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
  </Controls>
  <ViewDefinitions>
    <View>
      <Name>FileSystemTypes</Name>
      <ViewSelectedBy>
        <SelectionSetName>FileSystemTypes</SelectionSetName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth = 0;$true</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>FileSystemTypes.TreeNode</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$executionContext.SessionState.PSVariable.Remove("script:TreeDepth");$false</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Management.Automation.PSModuleInfoEZOut.RichModuleInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Management.Automation.PSModuleInfo</TypeName>
        <TypeName>EZOut.RichModuleInfo</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)


$module = $_
@(
    $moduleNameVer = $module.Name + $(
        if ($module.Version) {
            " [$($module.Version)]"
        }
    )
    . $EZOut_Heading $moduleNameVer -Level 1
    if ($module.Description) {
        . $EZOut_Heading $module.Description -UnderlineLength $moduleNameVer.Length
    }

    $commandSection = if ($module.ExportedCommands.Count) {

        $byVerb = $module.ExportedCommands.Values |
            Where-Object { $_.Verb } |
            Group-Object Verb |
            Sort-Object Name

        $maxVerbLength = $byVerb |
            Select-Object -ExpandProperty Name |
            Measure-Object -Property Length -Maximum |
            Select-Object -ExpandProperty Maximum

        $maxNounLength = $module.ExportedCommands.Values |
            Select-Object -ExpandProperty Noun |
            Measure-Object -Property Length -Maximum |
            Select-Object -ExpandProperty Maximum

        "|$(' ' * [Math]::Max($maxVerbLength - 4, 0))Verb|Noun$(' ' * [Math]::Max($maxNounLength - 4 + 1, 0))|"
        "|$('-' * [Math]::Max($maxVerbLength - 1, 0)):|:$('-' * [Math]::Max($maxNounLength, 0))|"

        foreach ($_ in $byVerb) {
            $v = "$($_.Name)"

            '|' +
                ' ' * ($maxVerbLength - $v.Length) + $v + '|' +
                $(
                    $t = '-' + $_.Group[0].Noun
                    $t + ' ' * ([Math]::Max($maxNounLength - $t.Length + 1, 0)) + '|'
                )
            if ($_.Group.Count -gt 1) {               
                foreach ($i in $_.Group[1..$($_.Group.Count -1)]) {
                    '|' + " " * ($maxVerbLength) + '|-' + $i.Noun + ' ' * ([Math]::Max($maxNounLength - $i.Noun.Length, 0)) + '|'
                }
            }
        }
    }

    if ($commandSection) {
        $commandLineLength = $commandSection | Measure-Object -Property Length -Maximum | Select-Object -ExpandProperty Maximum
        "### Commands"
        '-' * $commandLineLength
        $commandSection -join [Environment]::NewLine
        '-' * $commandLineLength
    }

    :findAboutText foreach ($culture in "$(Get-Culture)", 'en-us'| Select-Object -Unique) {
        $aboutTextFile = $module |
            Split-Path |
            Join-Path -ChildPath $culture |
            Join-Path -ChildPath "About_$module.help.txt"
        if (Test-Path $aboutTextFile) {
            [IO.File]::ReadAllText("$aboutTextFile")
            break
        } else {
            Write-Verbose "No help.txt file found at $aboutTextFile"
        }
    }
) -join [Environment]::NewLine</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Process.Heatmap</Name>
      <ViewSelectedBy>
        <TypeName>System.Diagnostics.Process</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>ProcessName</PropertyName>
        <CustomControlName>ProcessGroupControl</CustomControlName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>NPM(K)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>PM(K)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>WS(K)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>CPU(S)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Handles</PropertyName>
              </TableColumnItem>
              <!-- {ConditionalColor:"
        . $Heatmap $_.NPM -Min 16mb -Mid .5gb -Max 1gb 
&lt;#        if ($_.NPM -le 1MB) { &apos;#00FF00&apos;}
        elseif ($_.NPM -le 256mb) { &apos;#ffff00&apos; }
        else {
            &apos;#FF0000&apos;
        }#&gt;
    "}-->
              <TableColumnItem>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)


                $__ = $_
                $ci = . {
        . $EZOut_Heatmap $_.NPM -Min 16mb -Mid .5gb -Max 1gb 
&lt;#        if ($_.NPM -le 1MB) { '#00FF00'}
        elseif ($_.NPM -le 256mb) { '#ffff00' }
        else {
            '#FF0000'
        }#&gt;
    }
                $_ = $__
                if ($ci -is [string]) {
                    $ci = . $EZOut_SetOutputStyle $ci
                } else {
                    $ci = . $EZOut_SetOutputStyle @ci
                }
                $output = . { [long]($_.NPM / 1024) }
                @($ci; $output; . $EZOut_ClearOutputStyle) -join ""
                </ScriptBlock>
              </TableColumnItem>
              <!-- {ConditionalColor:" 
        . $Heatmap $_.PM -Min 16mb -Mid .5GB -Max 1gb 
        &lt;#if ($_.PM -le 1MB) { &apos;#00FF00&apos;}
        elseif ($_.PM -le 256mb) { &apos;#ffff00&apos; }
        else {
            &apos;#FF0000&apos;
        }#&gt;
    "}-->
              <TableColumnItem>
                <ScriptBlock>
                $__ = $_
                $ci = . { 
        . $EZOut_Heatmap $_.PM -Min 16mb -Mid .5GB -Max 1gb 
        &lt;#if ($_.PM -le 1MB) { '#00FF00'}
        elseif ($_.PM -le 256mb) { '#ffff00' }
        else {
            '#FF0000'
        }#&gt;
    }
                $_ = $__
                if ($ci -is [string]) {
                    $ci = . $EZOut_SetOutputStyle $ci
                } else {
                    $ci = . $EZOut_SetOutputStyle @ci
                }
                $output = . { [long]($_.PM / 1024) }
                @($ci; $output; . $EZOut_ClearOutputStyle) -join ""
                </ScriptBlock>
              </TableColumnItem>
              <!-- {ConditionalColor:"
        . $Heatmap $_.WS -Min 16mb -Mid 512mb -Max 1gb 
        &lt;#if ($_.PM -le 1MB) { &apos;#00FF00&apos;}
        elseif ($_.PM -le 256mb) { &apos;#ffff00&apos; }
        else {
            &apos;#FF0000&apos;
        }#&gt;
    "}-->
              <TableColumnItem>
                <ScriptBlock>
                $__ = $_
                $ci = . {
        . $EZOut_Heatmap $_.WS -Min 16mb -Mid 512mb -Max 1gb 
        &lt;#if ($_.PM -le 1MB) { '#00FF00'}
        elseif ($_.PM -le 256mb) { '#ffff00' }
        else {
            '#FF0000'
        }#&gt;
    }
                $_ = $__
                if ($ci -is [string]) {
                    $ci = . $EZOut_SetOutputStyle $ci
                } else {
                    $ci = . $EZOut_SetOutputStyle @ci
                }
                $output = . { [long]($_.WS / 1024) }
                @($ci; $output; . $EZOut_ClearOutputStyle) -join ""
                </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock> 
        if ($_.CPU -ne $()) { 
            $_.CPU.ToString("N") 
        }
    </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>ID</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>SI</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>process</Name>
      <ViewSelectedBy>
        <TypeName>System.Diagnostics.Process</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>ProcessName</PropertyName>
        <CustomControlName>ProcessGroupControl</CustomControlName>
      </GroupBy>
      <ListControl>
        <ListEntries>
          <ListEntry>
            <ListItems>
              <ListItem>
                <PropertyName>ID</PropertyName>
              </ListItem>
            </ListItems>
          </ListEntry>
        </ListEntries>
      </ListControl>
    </View>
    <View>
      <Name>System.Reflection.MemberInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Reflection.MemberInfo</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $ExecutionContext.SessionState.PSVariable.Set('Script:DisplayingMember',$true) </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $null </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeMemberControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $ExecutionContext.SessionState.PSVariable.Remove('Script:DisplayingMember') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $null </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Type</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>FullName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>BaseType</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>IsPublic</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>IsSerializable</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Type.Summary</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock> '| Format-Custom -View System.Type.Full for more'</ScriptBlock>
        <Label>Type Summary</Label>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> '-' * ($Host.UI.RawUI.BufferSize.Width - 1) </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' ' * 1 </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' ' * 1 </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BaseType -and -not $_.IsValueType </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        ':'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BaseType -and -not $_.IsValueType -and $_.BaseType -ne [Object] </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>BaseType</PropertyName>
                <CustomControlName>TypeBase</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetInterfaces() </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.GetInterfaces() | Sort-Object Name</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeBase</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Type.Full</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> '-' * ($Host.UI.RawUI.BufferSize.Width - 1) </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' ' * 1 </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'EZOut'
do {
    $lm = Get-Module -Name $moduleName -ErrorAction Ignore
    if (-not $lm) { continue } 
    if ($lm.FormatPartsLoaded) { break }
    $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
        foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
            $ParentNode = $partNodeName.Node.ParentNode
            "$($ParentNode.Name)={
$($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
        }
    }) -join [Environment]::NewLine
    New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
        Import-Module -Global
    $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
    
    if (-not $lm.OnRemove) {
        $lm.OnRemove = $onRemove
    } else {
        $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
    }
    $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force

} while ($false)

. $EZOut_SetOutputStyle -ForegroundColor 'Verbose'</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>. $EZOut_ClearOutputStyle</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' ' * 1 </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BaseType -and -not $_.IsValueType -and $_.BaseType -ne [Object] </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        ':'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BaseType -and -not $_.IsValueType -and $_.BaseType -ne [Object] </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>BaseType</PropertyName>
                <CustomControlName>TypeBase</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetInterfaces() </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.GetInterfaces() | Sort-Object Name</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeBase</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetConstructors('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Constructors:'           
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetConstructors('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GetConstructors('Instance,Public')
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetEvents('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine + ('#' * 3) + ' Events:'    
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetEvents('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GetEvents('Instance,Public') | Sort-Object Name
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeEventControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetProperties('Static,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine + ('#' * 3) + ' Static Properties:'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetProperties('Static,Public')</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GetProperties('Static,Public') | Sort-Object Name
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypePropertyControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetProperties('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine + ('#' * 3) + ' Properties:'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetProperties('Instance,Public')</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GetProperties('Instance,Public') | Sort-Object Name
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypePropertyControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetMethods('Static,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine + ('#' * 3) + ' Static Methods:'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetMethods('Static,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GetMethods('Static,Public') | Sort-Object Name | Where-Object { -not $_.IsSpecialName }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetMethods('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine + ('#' * 3) + ' Methods:'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetMethods('Instance,Public') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GetMethods('Instance,Public') | Sort-Object Name | Where-Object { -not $_.IsSpecialName } 
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Xml.XmlElement</Name>
      <ViewSelectedBy>
        <TypeName>System.Xml.XmlElement</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth = 0;$true</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlNodeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$executionContext.SessionState.PSVariable.Remove("script:TreeDepth");$false</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Xml.XmlDocument</Name>
      <ViewSelectedBy>
        <TypeName>System.Xml.XmlDocument</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth = 0;$true</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    @(foreach ($cn in $_.ChildNodes) {
        if ($cn -is [xml.xmldeclaration]) { continue }
        $cn
    })
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlNodeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$ExecutionContext.SessionState.PSVariable.Remove('script:TreeDepth'); $false</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $null </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
  </ViewDefinitions>
</Configuration>
